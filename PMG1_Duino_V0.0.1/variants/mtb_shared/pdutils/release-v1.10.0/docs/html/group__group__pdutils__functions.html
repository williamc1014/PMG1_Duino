<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PDUtils</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDUtils</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group__pdutils__functions.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Describes the PDUtils function prototypes. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1095bbcc98179719876b79e66252b71f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga1095bbcc98179719876b79e66252b71f">Cy_PdUtils_MemCalculateByteChecksum</a> (uint8_t *ptr, uint32_t size)</td></tr>
<tr class="memdesc:ga1095bbcc98179719876b79e66252b71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the checksum of the specified byte array.  <a href="#ga1095bbcc98179719876b79e66252b71f">More...</a><br /></td></tr>
<tr class="separator:ga1095bbcc98179719876b79e66252b71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3b25099f6269513d16b161ab716a42"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gafb3b25099f6269513d16b161ab716a42">Cy_PdUtils_MemCalculateWordChecksum</a> (uint16_t *ptr, uint32_t size)</td></tr>
<tr class="memdesc:gafb3b25099f6269513d16b161ab716a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the checksum of the specified WORD array.  <a href="#gafb3b25099f6269513d16b161ab716a42">More...</a><br /></td></tr>
<tr class="separator:gafb3b25099f6269513d16b161ab716a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156c28777ffe97f575d88a49df8b2dab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga156c28777ffe97f575d88a49df8b2dab">Cy_PdUtils_MemCalculateDwordChecksum</a> (uint32_t *ptr, uint32_t size)</td></tr>
<tr class="memdesc:ga156c28777ffe97f575d88a49df8b2dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the checksum of the specified DWORD array.  <a href="#ga156c28777ffe97f575d88a49df8b2dab">More...</a><br /></td></tr>
<tr class="separator:ga156c28777ffe97f575d88a49df8b2dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e012ab42c6c9b796d44db7279cb253"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga20e012ab42c6c9b796d44db7279cb253">Cy_PdUtils_Crc16</a> (uint16_t crc, uint8_t data)</td></tr>
<tr class="memdesc:ga20e012ab42c6c9b796d44db7279cb253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements CRC-16 with polynomial x^16 + x^15 + x^2 + 1 (0xA001).  <a href="#ga20e012ab42c6c9b796d44db7279cb253">More...</a><br /></td></tr>
<tr class="separator:ga20e012ab42c6c9b796d44db7279cb253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9901b61da7ca0de28221c6a62c90dc08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga9901b61da7ca0de28221c6a62c90dc08">Cy_PdUtils_MemCopyWord</a> (uint32_t *dest, const uint32_t *source, uint32_t size)</td></tr>
<tr class="memdesc:ga9901b61da7ca0de28221c6a62c90dc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies 32-bit data from one location to another.  <a href="#ga9901b61da7ca0de28221c6a62c90dc08">More...</a><br /></td></tr>
<tr class="separator:ga9901b61da7ca0de28221c6a62c90dc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d893d153c87585109c1e3d10fdd20cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga8d893d153c87585109c1e3d10fdd20cb">Cy_PdUtils_MemCopy</a> (uint8_t *dest, const uint8_t *source, uint32_t size)</td></tr>
<tr class="memdesc:ga8d893d153c87585109c1e3d10fdd20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data byte-by-byte.  <a href="#ga8d893d153c87585109c1e3d10fdd20cb">More...</a><br /></td></tr>
<tr class="separator:ga8d893d153c87585109c1e3d10fdd20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05c77e15fefc625974acaf9c408250b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gac05c77e15fefc625974acaf9c408250b">Cy_PdUtils_MemSet</a> (uint8_t *dest, uint8_t c, uint32_t size)</td></tr>
<tr class="memdesc:gac05c77e15fefc625974acaf9c408250b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a memory buffer.  <a href="#gac05c77e15fefc625974acaf9c408250b">More...</a><br /></td></tr>
<tr class="separator:gac05c77e15fefc625974acaf9c408250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2eb6b123ed64b8ead211e579f2e56c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga0a2eb6b123ed64b8ead211e579f2e56c">Cy_PdUtils_DivRoundUp</a> (uint32_t x, uint32_t y)</td></tr>
<tr class="memdesc:ga0a2eb6b123ed64b8ead211e579f2e56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides two unsigned integers and returns the quotient rounded up to the nearest integer.  <a href="#ga0a2eb6b123ed64b8ead211e579f2e56c">More...</a><br /></td></tr>
<tr class="separator:ga0a2eb6b123ed64b8ead211e579f2e56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24899a1c7bb7d09aadef0434630a37b3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga24899a1c7bb7d09aadef0434630a37b3">Cy_PdUtils_ApplyThreshold</a> (int32_t val, int8_t percentage)</td></tr>
<tr class="memdesc:ga24899a1c7bb7d09aadef0434630a37b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the threshold value based on the input value and the percentage by which the input value should be increased.  <a href="#ga24899a1c7bb7d09aadef0434630a37b3">More...</a><br /></td></tr>
<tr class="separator:ga24899a1c7bb7d09aadef0434630a37b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55e12d2aa7db1c243e9490a6d4393ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gaa55e12d2aa7db1c243e9490a6d4393ec">Cy_PdUtils_EventGroup_SetEvent</a> (uint32_t *event_map, uint8_t event_sel)</td></tr>
<tr class="memdesc:gaa55e12d2aa7db1c243e9490a6d4393ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a bit in an event group variable.  <a href="#gaa55e12d2aa7db1c243e9490a6d4393ec">More...</a><br /></td></tr>
<tr class="separator:gaa55e12d2aa7db1c243e9490a6d4393ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5106de063751245f77c1dd2a9e46c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gaf5106de063751245f77c1dd2a9e46c33">Cy_PdUtils_EventGroup_SetEventsByVal</a> (uint32_t *event_map, uint32_t event_sel)</td></tr>
<tr class="memdesc:gaf5106de063751245f77c1dd2a9e46c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one or more task values in an event group.  <a href="#gaf5106de063751245f77c1dd2a9e46c33">More...</a><br /></td></tr>
<tr class="separator:gaf5106de063751245f77c1dd2a9e46c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d8f790c715ec5b2121d29d85e7022a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga36d8f790c715ec5b2121d29d85e7022a">Cy_PdUtils_EventGroup_ClearEvent</a> (uint32_t *event_map, uint8_t event_sel)</td></tr>
<tr class="memdesc:ga36d8f790c715ec5b2121d29d85e7022a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a bit in an event group variable.  <a href="#ga36d8f790c715ec5b2121d29d85e7022a">More...</a><br /></td></tr>
<tr class="separator:ga36d8f790c715ec5b2121d29d85e7022a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3b14ac04e22df79ebd59fd3d36e01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga5c3b14ac04e22df79ebd59fd3d36e01a">Cy_PdUtils_EventGroup_ClearEventsByVal</a> (uint32_t *event_map, uint32_t event_sel)</td></tr>
<tr class="memdesc:ga5c3b14ac04e22df79ebd59fd3d36e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a bit in an event group variable.  <a href="#ga5c3b14ac04e22df79ebd59fd3d36e01a">More...</a><br /></td></tr>
<tr class="separator:ga5c3b14ac04e22df79ebd59fd3d36e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441687c9fcaf03d19433f63e2eefc6fe"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga441687c9fcaf03d19433f63e2eefc6fe">Cy_PdUtils_EventGroup_GetEvent</a> (volatile uint32_t *event_map, bool clr_stat)</td></tr>
<tr class="memdesc:ga441687c9fcaf03d19433f63e2eefc6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next pending event/task from an event group variable.  <a href="#ga441687c9fcaf03d19433f63e2eefc6fe">More...</a><br /></td></tr>
<tr class="separator:ga441687c9fcaf03d19433f63e2eefc6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dbf2a3b9ab3bee2473a045c3764b098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga9dbf2a3b9ab3bee2473a045c3764b098">Cy_PdUtils_SwTimer_Init</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__timer__config__t">cy_stc_pdutils_timer_config_t</a> *sw_timer_config)</td></tr>
<tr class="memdesc:ga9dbf2a3b9ab3bee2473a045c3764b098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the software timer module.  <a href="#ga9dbf2a3b9ab3bee2473a045c3764b098">More...</a><br /></td></tr>
<tr class="separator:ga9dbf2a3b9ab3bee2473a045c3764b098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908e17b45e1a49e977194b40d9edd7aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga908e17b45e1a49e977194b40d9edd7aa">Cy_PdUtils_SwTimer_Start</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, void *callbackContext, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id, uint16_t period, <a class="el" href="group__group__pdutils__data__structures.html#ga677655f9c592cb223c59bf38678c1a1a">cy_cb_timer_t</a> cb)</td></tr>
<tr class="memdesc:ga908e17b45e1a49e977194b40d9edd7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a specific soft timer.  <a href="#ga908e17b45e1a49e977194b40d9edd7aa">More...</a><br /></td></tr>
<tr class="separator:ga908e17b45e1a49e977194b40d9edd7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf63eb6183e67d5e079ccdfd427d654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga4cf63eb6183e67d5e079ccdfd427d654">Cy_PdUtils_SwTimer_StartWocb</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id, uint16_t period)</td></tr>
<tr class="memdesc:ga4cf63eb6183e67d5e079ccdfd427d654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a specific soft timer without providing a callback for expiry notification.  <a href="#ga4cf63eb6183e67d5e079ccdfd427d654">More...</a><br /></td></tr>
<tr class="separator:ga4cf63eb6183e67d5e079ccdfd427d654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb11653d85d800087648374c237dd15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga8fb11653d85d800087648374c237dd15">Cy_PdUtils_SwTimer_Stop</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id)</td></tr>
<tr class="memdesc:ga8fb11653d85d800087648374c237dd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops a soft timer that is currently running.  <a href="#ga8fb11653d85d800087648374c237dd15">More...</a><br /></td></tr>
<tr class="separator:ga8fb11653d85d800087648374c237dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf60e21257a752fe777f7a2a1fff3324"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gabf60e21257a752fe777f7a2a1fff3324">Cy_PdUtils_SwTimer_IsRunning</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id)</td></tr>
<tr class="memdesc:gabf60e21257a752fe777f7a2a1fff3324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specified soft timer is currently running.  <a href="#gabf60e21257a752fe777f7a2a1fff3324">More...</a><br /></td></tr>
<tr class="separator:gabf60e21257a752fe777f7a2a1fff3324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23aeb8ac3ac34ca97f1395d97fbccd35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga23aeb8ac3ac34ca97f1395d97fbccd35">Cy_PdUtils_SwTimer_RangeEnabled</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> low, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> high)</td></tr>
<tr class="memdesc:ga23aeb8ac3ac34ca97f1395d97fbccd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether any of the soft timers in the specified range are currently running.  <a href="#ga23aeb8ac3ac34ca97f1395d97fbccd35">More...</a><br /></td></tr>
<tr class="separator:ga23aeb8ac3ac34ca97f1395d97fbccd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3f3800828664a465b9b4793c735aec"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga1a3f3800828664a465b9b4793c735aec">Cy_PdUtils_SwTimer_GetCount</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id)</td></tr>
<tr class="memdesc:ga1a3f3800828664a465b9b4793c735aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time (in ms) remaining for timer expiration.  <a href="#ga1a3f3800828664a465b9b4793c735aec">More...</a><br /></td></tr>
<tr class="separator:ga1a3f3800828664a465b9b4793c735aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b0366b03e87bfba848af2de950f116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga98b0366b03e87bfba848af2de950f116">Cy_PdUtils_SwTimer_StopAll</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga98b0366b03e87bfba848af2de950f116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all active soft timers.  <a href="#ga98b0366b03e87bfba848af2de950f116">More...</a><br /></td></tr>
<tr class="separator:ga98b0366b03e87bfba848af2de950f116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462ac648aa79021a71f24207b5f0e639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga462ac648aa79021a71f24207b5f0e639">Cy_PdUtils_SwTimer_StopRange</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> start, <a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> end)</td></tr>
<tr class="memdesc:ga462ac648aa79021a71f24207b5f0e639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all soft timers with ids in the specified range.  <a href="#ga462ac648aa79021a71f24207b5f0e639">More...</a><br /></td></tr>
<tr class="separator:ga462ac648aa79021a71f24207b5f0e639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe881e33a77704dcaf551674337b164d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gabe881e33a77704dcaf551674337b164d">Cy_PdUtils_SwTimer_NumActive</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:gabe881e33a77704dcaf551674337b164d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active timers.  <a href="#gabe881e33a77704dcaf551674337b164d">More...</a><br /></td></tr>
<tr class="separator:gabe881e33a77704dcaf551674337b164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fab7d893e88ab1131d8084415bc769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga13fab7d893e88ab1131d8084415bc769">Cy_PdUtils_SwTimer_EnterSleep</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga13fab7d893e88ab1131d8084415bc769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the timer module and the hardware timer for entering device Deep Sleep.  <a href="#ga13fab7d893e88ab1131d8084415bc769">More...</a><br /></td></tr>
<tr class="separator:ga13fab7d893e88ab1131d8084415bc769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65f30cd64b060a2f0ff1ad9d9b3c2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gae65f30cd64b060a2f0ff1ad9d9b3c2a9">Cy_PdUtils_SwTimer_InterruptHandler</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:gae65f30cd64b060a2f0ff1ad9d9b3c2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the interrupt handler callback used by the soft timer module and is expected to be called by the application whenever the appropriate SysTick or WDT interrupt is received.  <a href="#gae65f30cd64b060a2f0ff1ad9d9b3c2a9">More...</a><br /></td></tr>
<tr class="separator:gae65f30cd64b060a2f0ff1ad9d9b3c2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df15242d60fbb030ac2858bfef58e8f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga5df15242d60fbb030ac2858bfef58e8f">Cy_PdUtils_SwTimer_GetMultiplier</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga5df15242d60fbb030ac2858bfef58e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of low frequency (LF) clock ticks required per ms.  <a href="#ga5df15242d60fbb030ac2858bfef58e8f">More...</a><br /></td></tr>
<tr class="separator:ga5df15242d60fbb030ac2858bfef58e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462d5297084a00b4701dd7127c95a609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga462d5297084a00b4701dd7127c95a609">Cy_PdUtils_HwTimer_Init</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga462d5297084a00b4701dd7127c95a609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the hardware timer block used by the soft timer module and is called as a part of the SW timer initialization.  <a href="#ga462d5297084a00b4701dd7127c95a609">More...</a><br /></td></tr>
<tr class="separator:ga462d5297084a00b4701dd7127c95a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2289ba3b4007e43264f2cdf31c64730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gad2289ba3b4007e43264f2cdf31c64730">Cy_PdUtils_HwTimer_Start</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:gad2289ba3b4007e43264f2cdf31c64730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a hardware timer.  <a href="#gad2289ba3b4007e43264f2cdf31c64730">More...</a><br /></td></tr>
<tr class="separator:gad2289ba3b4007e43264f2cdf31c64730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7eb2773498c9d8038b6730dd8bb9ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#gab7eb2773498c9d8038b6730dd8bb9ba1">Cy_PdUtils_HwTimer_Stop</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:gab7eb2773498c9d8038b6730dd8bb9ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the hardware timer.  <a href="#gab7eb2773498c9d8038b6730dd8bb9ba1">More...</a><br /></td></tr>
<tr class="separator:gab7eb2773498c9d8038b6730dd8bb9ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a754cca85a87b2cd986a436cccba4ca"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga9a754cca85a87b2cd986a436cccba4ca">Cy_PdUtils_HwTimer_GetCount</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga9a754cca85a87b2cd986a436cccba4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reading of the current hardware timer count.  <a href="#ga9a754cca85a87b2cd986a436cccba4ca">More...</a><br /></td></tr>
<tr class="separator:ga9a754cca85a87b2cd986a436cccba4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a9f01567222f75085fa05ee53e40eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdutils__functions.html#ga94a9f01567222f75085fa05ee53e40eb">Cy_PdUtils_HwTimer_LoadPeriod</a> (<a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *context, uint16_t period)</td></tr>
<tr class="memdesc:ga94a9f01567222f75085fa05ee53e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the hardware time period that is to be configured for interrupt.  <a href="#ga94a9f01567222f75085fa05ee53e40eb">More...</a><br /></td></tr>
<tr class="separator:ga94a9f01567222f75085fa05ee53e40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1095bbcc98179719876b79e66252b71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1095bbcc98179719876b79e66252b71f">&#9670;&nbsp;</a></span>Cy_PdUtils_MemCalculateByteChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_PdUtils_MemCalculateByteChecksum </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the checksum of the specified byte array. </p>
<p>The checksum is a simple function calculated as the 2's complement of the binary sum of all bytes in the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the data array.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the array in byte elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Checksum of the data array. </dd></dl>

</div>
</div>
<a id="gafb3b25099f6269513d16b161ab716a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb3b25099f6269513d16b161ab716a42">&#9670;&nbsp;</a></span>Cy_PdUtils_MemCalculateWordChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_PdUtils_MemCalculateWordChecksum </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the checksum of the specified WORD array. </p>
<p>The checksum is a simple function calculated as the 2's complement of the binary sum of all words in the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the data array.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the array in WORD elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Checksum of the data array. </dd></dl>

</div>
</div>
<a id="ga156c28777ffe97f575d88a49df8b2dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156c28777ffe97f575d88a49df8b2dab">&#9670;&nbsp;</a></span>Cy_PdUtils_MemCalculateDwordChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_PdUtils_MemCalculateDwordChecksum </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the checksum of the specified DWORD array. </p>
<p>The checksum is a simple function calculated as the 2's complement of the binary sum of all DWORDs in the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the data array.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the array in DWORD elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Checksum of the data array. </dd></dl>

</div>
</div>
<a id="ga20e012ab42c6c9b796d44db7279cb253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e012ab42c6c9b796d44db7279cb253">&#9670;&nbsp;</a></span>Cy_PdUtils_Crc16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_PdUtils_Crc16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements CRC-16 with polynomial x^16 + x^15 + x^2 + 1 (0xA001). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crc</td><td>Original CRC value.</td></tr>
    <tr><td class="paramname">data</td><td>Data byte to be included in CRC computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Updated CRC value including the new data byte. </dd></dl>

</div>
</div>
<a id="ga9901b61da7ca0de28221c6a62c90dc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9901b61da7ca0de28221c6a62c90dc08">&#9670;&nbsp;</a></span>Cy_PdUtils_MemCopyWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_MemCopyWord </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies 32-bit data from one location to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination.</td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source.</td></tr>
    <tr><td class="paramname">size</td><td>Size of data in 32-bit DWORD units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga8d893d153c87585109c1e3d10fdd20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d893d153c87585109c1e3d10fdd20cb">&#9670;&nbsp;</a></span>Cy_PdUtils_MemCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_MemCopy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data byte-by-byte. </p>
<p>Replacement for memcpy function. It is used in cases where a memcpy equivalent that can be placed in a specific memory region (such as the ROM) is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination buffer.</td></tr>
    <tr><td class="paramname">source</td><td>Pointer to source buffer.</td></tr>
    <tr><td class="paramname">size</td><td>Size of data to be copied (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gac05c77e15fefc625974acaf9c408250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac05c77e15fefc625974acaf9c408250b">&#9670;&nbsp;</a></span>Cy_PdUtils_MemSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_MemSet </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a memory buffer. </p>
<p>Replacement for the memset function. It is used in cases where a memset equivalent that can be placed in a specific memory region (such as the ROM) is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination buffer.</td></tr>
    <tr><td class="paramname">c</td><td>Data to be copied into each byte of the buffer.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga0a2eb6b123ed64b8ead211e579f2e56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2eb6b123ed64b8ead211e579f2e56c">&#9670;&nbsp;</a></span>Cy_PdUtils_DivRoundUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_PdUtils_DivRoundUp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides two unsigned integers and returns the quotient rounded up to the nearest integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dividend value.</td></tr>
    <tr><td class="paramname">y</td><td>Divisor value. Must be non-zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Quotient rounded up to the nearest integer. </dd></dl>

</div>
</div>
<a id="ga24899a1c7bb7d09aadef0434630a37b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24899a1c7bb7d09aadef0434630a37b3">&#9670;&nbsp;</a></span>Cy_PdUtils_ApplyThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Cy_PdUtils_ApplyThreshold </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>percentage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the threshold value based on the input value and the percentage by which the input value should be increased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Input value.</td></tr>
    <tr><td class="paramname">percentage</td><td>Value means how much (in percent) input value should be increased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t Sum of the input value and calculated threshold. </dd></dl>

</div>
</div>
<a id="gaa55e12d2aa7db1c243e9490a6d4393ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55e12d2aa7db1c243e9490a6d4393ec">&#9670;&nbsp;</a></span>Cy_PdUtils_EventGroup_SetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_EventGroup_SetEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>event_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>event_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a bit in an event group variable. </p>
<p>Event groups are DWORD (uint32_t) variables and hold a set of request bits that can be set/cleared independently. An event group facilitates the management of a set of related tasks or status bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_map</td><td>Holds the current status of the event group.</td></tr>
    <tr><td class="paramname">event_sel</td><td>Specifies the position of the event/task to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf5106de063751245f77c1dd2a9e46c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5106de063751245f77c1dd2a9e46c33">&#9670;&nbsp;</a></span>Cy_PdUtils_EventGroup_SetEventsByVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_EventGroup_SetEventsByVal </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>event_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one or more task values in an event group. </p>
<p>Event groups are DWORD (uint32_t) variables hold a set of request bits that can be set/cleared independently. An event group facilitates the management of a set of related tasks or status bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_map</td><td>Holds the current status of the event group.</td></tr>
    <tr><td class="paramname">event_sel</td><td>Specifies a set of event/task bits that should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga36d8f790c715ec5b2121d29d85e7022a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d8f790c715ec5b2121d29d85e7022a">&#9670;&nbsp;</a></span>Cy_PdUtils_EventGroup_ClearEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_EventGroup_ClearEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>event_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>event_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears a bit in an event group variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_map</td><td>Holds the current status of the event group.</td></tr>
    <tr><td class="paramname">event_sel</td><td>Specifies the position of the event/task to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5c3b14ac04e22df79ebd59fd3d36e01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c3b14ac04e22df79ebd59fd3d36e01a">&#9670;&nbsp;</a></span>Cy_PdUtils_EventGroup_ClearEventsByVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_EventGroup_ClearEventsByVal </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>event_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears a bit in an event group variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_map</td><td>Holds the current status of the event group.</td></tr>
    <tr><td class="paramname">event_sel</td><td>Specifies one or more event/task bits to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga441687c9fcaf03d19433f63e2eefc6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga441687c9fcaf03d19433f63e2eefc6fe">&#9670;&nbsp;</a></span>Cy_PdUtils_EventGroup_GetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_PdUtils_EventGroup_GetEvent </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>event_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clr_stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next pending event/task from an event group variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_map</td><td>Original status of the event group.</td></tr>
    <tr><td class="paramname">clr_stat</td><td>Specifies whether the event returned should be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Position of the event/task which has been detected and needs to be processed. </dd></dl>

</div>
</div>
<a id="ga9dbf2a3b9ab3bee2473a045c3764b098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dbf2a3b9ab3bee2473a045c3764b098">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_SwTimer_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__timer__config__t">cy_stc_pdutils_timer_config_t</a> *&#160;</td>
          <td class="paramname"><em>sw_timer_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the software timer module. </p>
<p>It initializes the data structures for timer management and enables the hardware timer used for the soft timer implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">sw_timer_config</td><td>Pointer to the SW timer module configuration context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__timer__config__t">cy_stc_pdutils_timer_config_t</a> configured by the user from application space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga908e17b45e1a49e977194b40d9edd7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga908e17b45e1a49e977194b40d9edd7aa">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_PdUtils_SwTimer_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga677655f9c592cb223c59bf38678c1a1a">cy_cb_timer_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a specific soft timer. </p>
<p>All soft timers are one-shot timers that run until the specified period has elapsed. The timer expiration callback will be called at the end of the period if one is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">callbackContext</td><td>Pointer to the caller context.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer ID.</td></tr>
    <tr><td class="paramname">period</td><td>Timer period in milliseconds.</td></tr>
    <tr><td class="paramname">cb</td><td>Timer expiration callback. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is started and false if the timer start fails. </dd></dl>

</div>
</div>
<a id="ga4cf63eb6183e67d5e079ccdfd427d654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cf63eb6183e67d5e079ccdfd427d654">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_StartWocb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_PdUtils_SwTimer_StartWocb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a specific soft timer without providing a callback for expiry notification. </p>
<p>The status of the timer (running or not) can be checked using the <a class="el" href="group__group__pdutils__functions.html#gabf60e21257a752fe777f7a2a1fff3324">Cy_PdUtils_SwTimer_IsRunning</a> API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer ID.</td></tr>
    <tr><td class="paramname">period</td><td>Timer period in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is started and false if the timer start fails. </dd></dl>

</div>
</div>
<a id="ga8fb11653d85d800087648374c237dd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb11653d85d800087648374c237dd15">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_SwTimer_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops a soft timer that is currently running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gabf60e21257a752fe777f7a2a1fff3324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf60e21257a752fe777f7a2a1fff3324">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_IsRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_PdUtils_SwTimer_IsRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specified soft timer is currently running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is running and false if the timer start fails. </dd></dl>

</div>
</div>
<a id="ga23aeb8ac3ac34ca97f1395d97fbccd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23aeb8ac3ac34ca97f1395d97fbccd35">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_RangeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_PdUtils_SwTimer_RangeEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether any of the soft timers in the specified range are currently running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">low</td><td>Lowest soft timer ID to be checked.</td></tr>
    <tr><td class="paramname">high</td><td>Highest soft timer ID to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timers are running and false if the timer start fails. </dd></dl>

</div>
</div>
<a id="ga1a3f3800828664a465b9b4793c735aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a3f3800828664a465b9b4793c735aec">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_PdUtils_SwTimer_GetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time (in ms) remaining for timer expiration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time remaining for the expiration of the soft timer. </dd></dl>
<p>Multiplier is for 10 ms; ensure to scale it back to 1 ms and return </p>

</div>
</div>
<a id="ga98b0366b03e87bfba848af2de950f116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b0366b03e87bfba848af2de950f116">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_StopAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_SwTimer_StopAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops all active soft timers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga462ac648aa79021a71f24207b5f0e639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462ac648aa79021a71f24207b5f0e639">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_StopRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_SwTimer_StopRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops all soft timers with ids in the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">start</td><td>Starting timer ID. The value is inclusive.</td></tr>
    <tr><td class="paramname">end</td><td>Ending timer ID. The value is inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gabe881e33a77704dcaf551674337b164d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe881e33a77704dcaf551674337b164d">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_NumActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_PdUtils_SwTimer_NumActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of active timers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of active timers. </dd></dl>

</div>
</div>
<a id="ga13fab7d893e88ab1131d8084415bc769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fab7d893e88ab1131d8084415bc769">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_EnterSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_SwTimer_EnterSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares the timer module and the hardware timer for entering device Deep Sleep. </p>
<p>This must be called before entering Deep Sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae65f30cd64b060a2f0ff1ad9d9b3c2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae65f30cd64b060a2f0ff1ad9d9b3c2a9">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_SwTimer_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the interrupt handler callback used by the soft timer module and is expected to be called by the application whenever the appropriate SysTick or WDT interrupt is received. </p>
<p>It scans all running timer instances and decrements their count as appropriate. If any of the timers has expired, it is stopped, de-allocated, and the corresponding callback is called (if not NULL). The timer can be restarted from the callback function if so desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5df15242d60fbb030ac2858bfef58e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5df15242d60fbb030ac2858bfef58e8f">&#9670;&nbsp;</a></span>Cy_PdUtils_SwTimer_GetMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_PdUtils_SwTimer_GetMultiplier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of low frequency (LF) clock ticks required per ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of LF clock ticks per ms. </dd></dl>

</div>
</div>
<a id="ga462d5297084a00b4701dd7127c95a609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462d5297084a00b4701dd7127c95a609">&#9670;&nbsp;</a></span>Cy_PdUtils_HwTimer_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_HwTimer_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the hardware timer block used by the soft timer module and is called as a part of the SW timer initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initializes the hardware timer block used by the soft timer module and is called as a part of the SW timer initialization.</p>
<p>Calibrates the ILO based hw timer module used for the soft timer implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad2289ba3b4007e43264f2cdf31c64730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2289ba3b4007e43264f2cdf31c64730">&#9670;&nbsp;</a></span>Cy_PdUtils_HwTimer_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_HwTimer_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a hardware timer. </p>
<p>The timer is expected to trigger an interrupt at the configured time period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gab7eb2773498c9d8038b6730dd8bb9ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7eb2773498c9d8038b6730dd8bb9ba1">&#9670;&nbsp;</a></span>Cy_PdUtils_HwTimer_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_HwTimer_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the hardware timer. </p>
<p>The timer is expected to disable interrupts when it is stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga9a754cca85a87b2cd986a436cccba4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a754cca85a87b2cd986a436cccba4ca">&#9670;&nbsp;</a></span>Cy_PdUtils_HwTimer_GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_PdUtils_HwTimer_GetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reading of the current hardware timer count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the elapsed hardware block timer count. </dd></dl>

</div>
</div>
<a id="ga94a9f01567222f75085fa05ee53e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a9f01567222f75085fa05ee53e40eb">&#9670;&nbsp;</a></span>Cy_PdUtils_HwTimer_LoadPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdUtils_HwTimer_LoadPeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the hardware time period that is to be configured for interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the context structure <a class="el" href="group__group__pdutils__data__structures.html#structcy__stc__pdutils__sw__timer__t">cy_stc_pdutils_sw_timer_t</a> allocated by the user. The structure is used during the SW timer operation for internal configuration and data retention. Do not modify anything in this structure.</td></tr>
    <tr><td class="paramname">period</td><td>Time period to be configured for interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PDUtils</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
